# 이진변환 반복하기.

## try01 - "0"을 제거하는데 strip을 사용
def solution(s):
    # [변환 회차, 제거된 0의 수]
    cnt = 0
    zero_cnt = 0
    # while len(s) > 2: 
    #     cnt += 1
    #     zero_cnt += s.count("0")
    #     s.strip("0")
    # return cnt, zero_cnt
    print(len(s))
    print(s.count("0"))
    print(s.strip("0"))

'''
테스트 1
        입력값 〉	"110010101001"
        기댓값 〉	[3, 8]
        실행 결과 〉	실행한 결괏값 null이 기댓값 [3,8]과 다릅니다.
        출력 〉	12
                6
                110010101001

테스트 2
        입력값 〉	"01110"
        기댓값 〉	[3, 3]
        실행 결과 〉	실행한 결괏값 null이 기댓값 [3,3]과 다릅니다.
        출력 〉	5
                2
                111
-> 처음 while문을 돌렸을 때 시간초과가 나와서 확인해보니, 
테스트2의 경우 strip매서드가 제대로 작동되었으나 테스트1의 경우 예상되로 작동되지 않음으로 알게됨.
" strip 명령어는 좌측 또는 우측에 가장 첫번째로 오는 문자열만 삭제 시도"되기 때문이었다.
-> 처음에는 "1"이 있다는 것을 인식한 이후, 
연산을 끝내는 것이라고 생각했으나 아래와 같이 테스트 케이스를 확인하고 다시 기술 블로그등을 찾아 본 결과 
해당 생각이 아니었다고 확인이 되었다.
-> 돌 다리도 두드려보자

테스트 4
        입력값 〉	"010101"
        기댓값 〉	[3, 4]
        실행 결과 〉	실행한 결괏값 null이 기댓값 [3,4]과 다릅니다.
        출력 〉	6
                3
                10101
테스트 5
        입력값 〉	"101010"
        기댓값 〉	[3, 4]
        실행 결과 〉	실행한 결괏값 null이 기댓값 [3,4]과 다릅니다.
        출력 〉	6
                3
                10101

'''

## try02 - strip대신 replace를 사용
## 0.01ms, 10.2MB / 1.95ms, 10.2MB
def solution(s):
    # [변환 회차, 제거된 0의 수]
    cnt = 0
    zero_cnt = 0
    while len(s) != 1: 
        cnt += 1
        zero_cnt += s.count("0")
        s = s.replace("0", "")
        s = bin(len(s))[2:]
    return cnt, zero_cnt

## try03 - count 사용
## 0.00ms, 10.2MB / 0.49ms, 10.2MB
def solution(s):
    a, b = 0, 0
    while s != '1':
        a += 1
        num = s.count('1')
        b += len(s) - num
        s = bin(num)[2:] # num = "0을 제거한 s문자열의 길이"
    return [a, b]
'''
repalce를 사용해서 s를 다시 읽거나 하지않기에 더 빠르게 답을 구할 수 있음.
'''